package com.fengxiaoshuai.inheritdemo2;

public class BaseDemo {
    // 子类到底能继承父类中的哪些内容
    // 构造方法:非私有(不能) private(不能)
    // 成员变量:非私有(能)   private(能)
    // 成员方法:非私有(能)   private(不能)

    // 虚方法表:非private 非static 非final
    // 只有父类中的虚方法才能别子类继承

    // 继承中:成员变量的访问特点
    // 就近原则(谁离我近,我就用谁):先在局部位置找,本类成员位置找,父类成员位置找,逐级往上
    // 如果出现了重名的成员变量:this(本类) super(父类)

    // 继承中:成员方法的访问特点
    // 就近原则(谁离我近,我就用谁)
    // super调用,直接访问父类
    // 当父类的方法不能满足子类现在的需求时,需要进行方法重写
    // 在继承体系中,子类出现了和父类中一模一样的方法声明,我们就称子类这个方法是重写的方法。
    // @Override是放在重写后的方法上,检验子类重写时语法是否正确;加上注解后如果有红色波浪线,表示语法错误。
    // 如果发生了方法重写,则子类就会继承来虚方法表中的该方法进行覆盖。
    // 重写方法的名称、形参列表必须与父类中的一致。
    // 子类重写父类方法时,访问权限:子类必须大于等于父类(空着不写 < protected < public)
    // 子类重写父类方法时,返回值类型:子类必须小于等于父类
    // 重写方法尽量和父类保持一致
    // 只有被添加到虚方法表中的方法才能被重写

    // 继承中:构造方法的访问特点
    // 父类中的构造方法不会被子类继承的
    // 子类中所有的构造方法默认先访问父类中的无参构造,再执行自己
    // 子类在初始化之前,有可能会使用到父类中的数据,如果父类没有完成初始化,子类将无法使用父类的数据
    // 子类初始化之前,一定要调用父类构造方法完成父类数据空间的初始化
    // 子类构造方法的第一行语句默认是:super(),不写也存在,且必须在第一行
    // 如果子类想调用父类的有参构造,必须手动写super进行调用




}
